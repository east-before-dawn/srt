Haskell求优化，SPOJ GSS2
2968
<p>线段树O(nlogn)，<a href="http://ideone.com/XI8FT" target="_blank">http://ideone.com/XI8FT</a></p><p>module Main where<br>     <br>import Data.List<br>     <br>main<br> = do<br> getLine<br> 第二行 &lt;- getLine<br> let 数列 = map (read::String-&gt;Integer) (words 第二行)<br> getLine<br> 询问字符串 &lt;- getContents<br> let 一些询问 = map (map (read::String-&gt;Int))<br> $ map words<br> $ lines 询问字符串<br> putStr $ unlines $ map show $ 处理 数列 一些询问<br>     <br>最小值 = -100001;<br>否则 = otherwise<br>     <br>data SegTree<br> = Nil<br> | SegTree {<br> 左子树, 右子树 :: !SegTree,<br> 标签, 变化 :: !(Integer, Integer),<br> 边界 :: !(Int, Int)<br> } deriving Show<br>     <br>无变化 = (0, 0)<br>空标签 = (0, 0)<br>     <br>处理 :: [Integer] -&gt; [[Int]] -&gt; [Integer]<br>     <br>处理 数列 一些询问<br> = 答案<br> where<br> 排序的询问 = sortBy (\([_,d1],_) ([_,d2],_) -&gt; compare d1 d2) $ zip 一些询问 [1..]<br> 排序的数列 = sort $ zip 数列 [1..]<br> 整理好的数列 = sort $ 整理数列 (最小值, 0) 排序的数列<br> 整理数列 (上一个数, 上一个位置) ((这个数, 当前位置):后面的数列)<br> | 上一个数 &lt; 这个数<br> = (当前位置, 这个数, 0) : 整理数列 (这个数, 当前位置) 后面的数列<br> | 否则<br> = (当前位置, 这个数, 上一个位置) : 整理数列 (这个数, 当前位置) 后面的数列<br> 整理数列 _ _ = []<br> 线段树 = 建立线段树 1 (length 数列)<br> 答案 = map snd $ sort $ 迭代处理 线段树 排序的询问 整理好的数列<br>     <br>建立线段树 :: Int -&gt; Int -&gt; SegTree<br>     <br>建立线段树 左边界 右边界<br> | 左边界 == 右边界<br> = SegTree {左子树=Nil, 右子树=Nil, 标签=空标签, 变化=无变化, 边界=(左边界,右边界)}<br> | 否则<br> = SegTree {左子树=当前左子树, 右子树=当前右子树, 标签=空标签, 变化=无变化, 边界=(左边界,右边界)}<br> where<br> 分界线 = div (左边界+右边界) 2<br> 当前左子树 = 建立线段树 左边界 分界线<br> 当前右子树 = 建立线段树 (分界线+1) 右边界<br>     <br>迭代处理 线段树 所有询问@(当前询问:后面的询问) 所有数@((当前位置,这个数,上一个位置):后面的数)<br> | 询问右界&lt;当前位置<br> = (询问标号, 询问结果) : 迭代处理 新线段树 后面的询问 所有数<br> | 否则<br> = 迭代处理 (应用变化 线段树 (上一个位置+1, 当前位置) (这个数, max 这个数 0)) 所有询问 后面的数<br> where<br> ([询问左界, 询问右界],询问标号) = 当前询问<br> (询问结果, 新线段树) = 查询 线段树 (询问左界, 询问右界)<br>     <br>迭代处理 线段树 所有询问@(当前询问:后面的询问) 所有数<br> = (询问标号, 询问结果) : 迭代处理 新线段树 后面的询问 所有数<br> where<br> ([询问左界, 询问右界],询问标号) = 当前询问<br> (询问结果, 新线段树) = 查询 线段树 (询问左界, 询问右界)<br>     <br>迭代处理 _ _ _<br> = []<br>     <br>查询 线段树 询问@(询问左界, 询问右界)<br> | 右界&lt;询问左界 || 询问右界&lt;左界<br> = (0, 线段树)<br> | 询问左界&lt;=左界 &amp;&amp; 右界&lt;=询问右界<br> = (最大值, 线段树)<br> | 否则<br> = (max 左值 右值, 线段树{变化=无变化, 左子树=新左子树, 右子树=新右子树})<br> where<br> (左界,右界) = 边界 线段树<br> (_,最大值) = 标签 线段树<br> (左值, 新左子树) = 查询 (应用变化 (左子树 线段树) (边界 线段树) (变化 线段树)) 询问<br> (右值, 新右子树) = 查询 (应用变化 (右子树 线段树) (边界 线段树) (变化 线段树)) 询问<br>     <br>应用变化 线段树 区间@(区间左界, 区间右界) 这次变化@(总变化,优化变化)<br> | 右界&lt;区间左界 || 区间右界&lt;左界<br> = 线段树<br> | 区间左界&lt;=左界 &amp;&amp; 右界&lt;=区间右界<br> = 线段树{标签=重铸 原标签 这次变化, 变化=重铸 原变化 这次变化}<br> | 否则<br> = 线段树{左子树=应用后左子树, 右子树=应用后右子树, 标签=融合 (标签 应用后左子树) (标签 应用后右子树), 变化=无变化}<br> where<br> (左界,右界) = 边界 线段树<br> 新左子树 = (应用变化 (左子树 线段树) (边界 线段树) (变化 线段树))<br> 应用后左子树 = (应用变化 新左子树 区间 这次变化)<br> 新右子树 = (应用变化 (右子树 线段树) (边界 线段树) (变化 线段树))<br> 应用后右子树 = (应用变化 新右子树 区间 这次变化)<br> 原变化 = 变化 线段树<br> 原标签 = 标签 线段树<br>     <br>重铸 (总标签, 优化标签) (总变化, 优化变化)<br> = (总标签+总变化, max 优化标签 (总标签+优化变化))<br>     <br>融合 (a, b) (c, d)<br> = (max a c, max b d)</p>
0
2011-08-08 19:51:11:000
4
0
80
12
